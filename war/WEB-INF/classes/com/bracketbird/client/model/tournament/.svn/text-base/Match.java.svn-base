package com.moveit.client.model.tournament;

import com.moveit.client.model.Model;
import com.moveit.client.model.PlayingTeam;
import com.moveit.client.model.WalkOverTeam;
import com.moveit.client.model.keys.ClubId;
import com.moveit.client.model.keys.MatchId;
import com.moveit.client.model.keys.PlayingTeamId;
import com.moveit.client.util.EqualsUtil;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;

/**
 *
 */
public class Match extends Model<MatchId> {
    private static final long serialVersionUID = -8624209794497350221L;

    private transient List<TournamentListener<MatchEvent>> matchListener = new ArrayList<TournamentListener<MatchEvent>>();


    private ClubId clubId;

    private TournamentLevel level;

    //used in group-play
    private Integer group;

    //what round does this match belong to
    private Long round;

    //the order of the match in a subtournament
    private Integer order;

    //used in knockout - to reference between mathces (who meets who).
    private String name;

    private PlayingTeam teamHome;

    private PlayingTeam teamOut;


    private Date createdDate;

    private Date lastChangeDate;

    private Result result;

    private String field;


    public Match() {

    }


    public ClubId getClubId() {
        return clubId;
    }

    public void setClubId(ClubId clubId) {
        this.clubId = clubId;
    }

    public PlayingTeam getTeamHome() {
        return teamHome;
    }

    public void setTeamHome(PlayingTeam teamHome) {
        this.teamHome = teamHome;
    }

    public PlayingTeam getTeamOut() {
        return teamOut;
    }

    public void setTeamOut(PlayingTeam teamOut) {
        this.teamOut = teamOut;

    }

    public void updateTeamOut(PlayingTeam team, boolean fromClient){
        if(!EqualsUtil.equals(this.teamOut, team)){
            this.teamOut = team;
            fireMatchChangedEvent(fromClient);
        }
    }


    public void updateTeamHome(PlayingTeam team, boolean fromClient){
        if(!EqualsUtil.equals(this.teamHome, team)){
            this.teamHome = team;
            fireMatchChangedEvent(fromClient);
        }
    }

    public Integer getGroup() {
        return group;
    }

    public void setGroup(Integer group) {
        this.group = group;
    }

    public Long getRound() {
        return round;
    }

    public void setRound(Long round) {
        this.round = round;
    }

    public Integer getOrder() {
        return order;
    }

    public void setOrder(Integer order) {
        this.order = order;
    }


    public Date getCreatedDate() {
        return createdDate;
    }

    public void setCreatedDate(Date createdDate) {
        this.createdDate = createdDate;
    }

    public Date getLastChangeDate() {
        return lastChangeDate;
    }

    public void setLastChangeDate(Date lastChangeDate) {
        this.lastChangeDate = lastChangeDate;
    }

    public void addMatchChangedListener(TournamentListener<MatchEvent> l) {
        this.matchListener.add(l);
    }

    public void setResult(Result r) {
        result = r;
    }


    public void updateResult(Result r, boolean fromClient) {
        Result old = result;
        result = r;
        if (!EqualsUtil.equals(old, r)) {
            fireMatchChangedEvent(fromClient);
            level.matchUpdated(this, fromClient);

        }
    }

    private void fireMatchChangedEvent(boolean fromClient) {
        MatchEvent event = new MatchEvent(fromClient, this);
        for (TournamentListener<MatchEvent> l : matchListener) {
            l.onChange(event);
        }
    }


    public String getField() {
        return field;
    }

    public void setField(String f) {
        this.field = f;
    }

    public void updateField(String f, boolean fromClient) {
        String old = field;
        field = f;
        if (!EqualsUtil.equals(old, f)) {
            fireMatchChangedEvent(fromClient);
        }
    }

    public boolean hasResult() {
        return result != null;
    }

    public PlayingTeam getWinningTeam(){
        if(!isFinish()){
            return null;
        }
        if(isWalkover()){
            return getTeamHome() instanceof WalkOverTeam ? getTeamOut() : getTeamHome();
        }
        return homeIsWinning() ? getTeamHome() : getTeamOut();
    }

    public boolean homeIsWinning() {
        return hasResult() && result.homeIsWinning();
    }

    public boolean outIsWinning() {
        return hasResult() && result.outIsWinning();
    }

    public boolean isDraw() {
        return hasResult() && result.isDraw();
    }

    public String resultAsString() {
        return !hasResult() ? "" : result.asString();
    }


    public Result getResult() {
        return result;
    }

    public boolean isFinish() {
        return result != null || isWalkover();
    }

    public boolean isHome(PlayingTeamId id) {
        return teamHome.equals(id);
    }

    public TournamentLevel getLevel() {
        return level;
    }

    public void setLevel(TournamentLevel level) {
        this.level = level;
    }

    public void updateState() {
        //if(new state) - level.calculatestate()
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }


    public boolean isWalkover() {
        return getTeamHome() instanceof WalkOverTeam || getTeamOut() instanceof WalkOverTeam;
    }

    @Override
    public String toString() {
        return "Match{" + teamHome.getName() + " - " + teamOut.getName() + '}';
    }

}