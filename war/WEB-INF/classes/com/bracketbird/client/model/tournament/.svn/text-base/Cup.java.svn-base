package com.moveit.client.model.tournament;

import com.moveit.client.model.*;

import java.util.List;

/**
 *
 */
public class Cup extends TournamentLevel {


    private static final long serialVersionUID = 2056092174233628140L;

    public Cup() {
        super();
    }

    public Cup(Tournament t) {
        super(t);
    }


    public String getName() {
        if (getRounds() == null || getRounds().size() == 0) {
            return "Knockout";
        }

        return getRounds().size() == 1 ? "Knockout final" : ("Knockout 1/" + binaryCount());
    }

    @Override
    void matchUpdated(Match match, boolean fromClient) {
        if (match.isFinish()) {
            updateMatchInNextRound(match);
        }
        super.matchUpdated(match, fromClient);
    }

    private void updateMatchInNextRound(Match m) {
        if (m.isFinish() && hasNextRound(m)) {
            CupRound nextRound = (CupRound)getRounds().get(m.getRound().intValue());
            CupRound thisRound = (CupRound)getRounds().get((int)(m.getRound() - 1));

            Match nextMatch = nextRound.getMatch(thisRound.getMatchIndexInNextRound(m));

            PlayingTeam winingTeam = m.getWinningTeam();

            if (thisRound.isHomeTeamInNextRound(m)) {
                nextMatch.setTeamHome(winingTeam);
            }
            else {
                nextMatch.updateTeamOut(winingTeam, true);
            }
        }
    }

    private boolean hasNextRound(Match m){
        return getRounds().size() > m.getRound()-1;
    }

    private int binaryCount() {
        int count = 1;
        for (Round round : rounds) {
            count = count * 2;
        }
        return count / 2;
    }


    protected void layoutMathces() {
        super.layoutMathces();
        handleWalkovers();
    }

    private void handleWalkovers() {
        if (getRounds().size() < 2) {
            return;
        }
        CupRound thisRound = (CupRound) getRounds().get(0);
        //index of match to be updated with winning team.
        int indexNextRound;
        List<Match> fms = thisRound.getFinishedMatches();

        for (Match m : fms) {
            updateMatchInNextRound(m);
        }
    }


    @Override
    public Scheduler getScheduler() {
        return new CupScheduler(startingTeams, this);
    }


}

