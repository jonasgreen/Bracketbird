package com.moveit.client.model.tournament;

import com.moveit.client.constants.TournamentLevelConstant;
import com.moveit.client.model.*;
import com.moveit.client.model.keys.TournamentLevelId;
import com.moveit.client.model.keys.TournamentId;
import com.moveit.client.util.CollectionUtil;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;

/**
 *
 */
public abstract class TournamentLevel extends Model<TournamentLevelId> {
    private static final long serialVersionUID = -8838821453128489654L;

    private transient List<TournamentListener<LevelStateEvent>> stateListener = new ArrayList<TournamentListener<LevelStateEvent>>();
    private transient List<TournamentListener<LevelSettingsEvent>> settingsListener = new ArrayList<TournamentListener<LevelSettingsEvent>>();

    private TournamentLevelState state = new LevelStateEmpty();


    //each round holds all the mathces in one round (from all groups).
    protected List<Round> rounds = new ArrayList<Round>();

    private TournamentId tournamentId;
    private Integer type;
    protected Tournament tournament;


    private LevelSettings levelSettings = new LevelSettings();

    protected List<PlayingTeam> startingTeams = new ArrayList<PlayingTeam>();
    protected List<PlayingTeam> endingTeams = new ArrayList<PlayingTeam>();


    private Date createdDate;
    private Date lastChangeDate;


    public TournamentLevel() {
    }

    protected TournamentLevel(Tournament tournament) {
        this.tournament = tournament;
    }


    public Date getCreatedDate() {
        return createdDate;
    }

    public void setCreatedDate(Date createdDate) {
        this.createdDate = createdDate;
    }

    public Date getLastChangeDate() {
        return lastChangeDate;
    }

    public void setLastChangeDate(Date lastChangeDate) {
        this.lastChangeDate = lastChangeDate;
    }

    public abstract Scheduler getScheduler();

    public List<PlayingTeam> getStartingTeams() {
        return startingTeams;
    }

    public void setStartingTeams(List<PlayingTeam> startingTeams) {
        this.startingTeams = startingTeams;
    }


    public void updateStartingTeams(List<PlayingTeam> startingTeams) {
        this.startingTeams = startingTeams;
    }

    public TournamentId getTournamentId() {
        return tournamentId;
    }

    public void setTournamentId(TournamentId tournamentId) {
        this.tournamentId = tournamentId;
    }

    public void clear(boolean notifyParent, boolean fromClient) {
        clearTeams();
        clearMatches();
        updateState(notifyParent, fromClient);
    }

    private void clearTeams() {
        startingTeams = new ArrayList<PlayingTeam>();
    }

    public void clearMatches() {
        rounds = new ArrayList<Round>();
    }


    public Integer getType() {
        return type;
    }

    public void setType(Integer type) {
        this.type = type;
    }

    public boolean isFinish() {
        return state instanceof LevelStateInFinished;
    }

    public void layoutMatches(boolean fromClient) {
            layoutTeams();
            layoutMathces();
            updateState(true, fromClient);
    }

    public boolean layoutMatchesAllowed(){
        return isEmpty();
    }

    protected void layoutMathces() {
        Scheduler m = getScheduler();
        rounds = m.getRounds();
    }


    public void finished(List<PlayingTeam> finalRank, boolean fromClient) {
          //TODO - is allowed regarding state
        this.endingTeams = finalRank;
        //notified from rtc
        updateState(false, fromClient);
        tournament.finished(this, fromClient);
    }

    protected void layoutTeams() {
        TournamentLevel previous = getTournament().getPrevious(this);
        if (previous == null) {
            this.startingTeams = getTournament().getPlayingTeams();
        }
        else {
            if (!previous.isFinish()) {
                this.startingTeams = getSeedingTeams();
            }
            else {
                Integer maxTeams = getStageSettings().getMaxNumberOfTeams();
                if (maxTeams == null) {
                    this.startingTeams = previous.getEndingTeams();
                }
                else {
                    this.startingTeams = new ArrayList<PlayingTeam>();
                    for (int i = 0; i < maxTeams; i++) {
                        this.startingTeams.add(previous.getEndingTeams().get(i));
                    }
                }

            }
        }


    }

    protected List<PlayingTeam> getSeedingTeams() {
        List<PlayingTeam> list = new ArrayList<PlayingTeam>();
        int seed = 1;

        Integer numberOfTeams = getMaxNumberOfTeams();
        int i = 0;
        while (i < numberOfTeams) {
            list.add(new SeedingTeam(seed++));
            i++;
        }
        return list;
    }


    public boolean isInProgress() {
        return state instanceof LevelStateInProgress;
    }

    public boolean isMatchesLayedOut() {
        return state instanceof LevelStateMatchesLayedOut;
    }

    public boolean isEmpty() {
        return state instanceof LevelStateEmpty;
    }


    public void updateState(boolean notifyParent, boolean fromClient) {
        TournamentLevelState newState = calculateState();
        System.out.println("New Level State: "+newState);
        setNewState(newState, notifyParent, fromClient);
    }

    private TournamentLevelState calculateState() {
        if(hasEndingTeams()){
            return new LevelStateInFinished();
        }
        if (hasMatches()) {
            boolean someIsNonFinished = false;
            boolean someIsFinished = false;
            List<Match> matches = getMatches();

            for (Match match : matches) {
                if (match.isFinish()) {
                    someIsFinished = true;
                    if (someIsNonFinished) {
                        return new LevelStateInProgress();
                    }
                }
                else {
                    someIsNonFinished = true;
                    if (someIsFinished) {
                        return new LevelStateInProgress();
                    }
                }
            }
            //all the matches are in same state
            return matches.get(0).isFinish() ? new LevelStateAllMatchesPlayed() : new LevelStateMatchesLayedOut();
        }
        else {//Not Ready
            return new LevelStateEmpty();
        }
    }

    private boolean hasEndingTeams() {
        return !getEndingTeams().isEmpty();
    }

    public List<Match> getMatches() {
        List<Match> list = new ArrayList<Match>();
        for (Round r : getRounds()) {
            list.addAll(r.getMatches());
        }
        return list;
    }

    public boolean hasMatches() {
        if (rounds == null || rounds.isEmpty()) {
            return false;
        }
        for (Round round : rounds) {
            if (!round.getMatches().isEmpty()) {
                return true;
            }
        }
        return false;
    }

    private void setNewState(TournamentLevelState newState, boolean notifyParent, boolean fromClient) {
        if (!state.equals(newState)) {
            LevelStateEvent event = new LevelStateEvent(state, newState, fromClient);
            state = newState;
            fireStateChanged(event);
            if (notifyParent) {
                tournament.updateState(fromClient);
            }
        }
    }


    @Override
    public String toString() {
        return "Subtournament{" +
                ", state=" + state +
                ", matches=" + getMatches() +
                ", teams=" + startingTeams +
                "}";
    }

    public void setStageSettings(LevelSettings ss){
        this.levelSettings = ss;
    }

    public void updateStageSettings(LevelSettings ss, boolean fromClient) {
        if (!levelSettings.equals(ss)) {
            this.levelSettings = ss;
            clear(false, fromClient);
            LevelSettingsEvent e = new LevelSettingsEvent(ss, fromClient);
            fireSettingsChanged(e);
            updateState(true, fromClient);
        }
    }

    public LevelSettings getStageSettings() {
        return levelSettings;
    }

    public String getName() {
        return TournamentLevelConstant.get(type).getText();
    }

    public List<Round> getRounds() {
        return rounds;
    }

    public void setRounds(List<Round> rounds) {
        this.rounds = rounds;
    }


    private void fireStateChanged(LevelStateEvent e) {
        for (TournamentListener<LevelStateEvent> l : stateListener) {
            l.onChange(e);
        }
    }

    private void fireSettingsChanged(LevelSettingsEvent e) {
        for (TournamentListener<LevelSettingsEvent> l : settingsListener) {
            l.onChange(e);
        }
    }



    public void addStateListener(TournamentListener<LevelStateEvent> l) {
        stateListener.add(l);
    }


    public void addSettingsListener(TournamentListener<LevelSettingsEvent> l) {
        settingsListener.add(l);
    }


    public int getMaxNumberOfTeams() {
        return tournament.getMaxNumberOfTeams(this);
    }


    public Tournament getTournament() {
        return tournament;
    }

    public void setTournament(Tournament tournament) {
        this.tournament = tournament;
    }

    public List<PlayingTeam> getEndingTeams() {
        return endingTeams;
    }

    public void setEndingTeams(List<PlayingTeam> endingTeams) {
        this.endingTeams = endingTeams;
    }


    void matchUpdated(Match match, boolean fromClient){
        updateState(true, fromClient);
    }
}